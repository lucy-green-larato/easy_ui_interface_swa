// /src/js/ch-strategic.js
// Inside Track · Strategic review evidence — client module
// Wires form, validates inputs, calls API, handles progress/download/diagnostics.

const API_BASE = '/api/ch-strategic';

// ---------- DOM ----------
const els = {
  form: document.getElementById('ch-strategic-form'),
  callType: document.getElementById('call_type'),
  rememberCallType: document.getElementById('remember_call_type'),
  mapLabel: document.getElementById('map-label'),

  evidenceTag: document.getElementById('evidence_tag'),
  evidenceErr: document.getElementById('evidence_error'),

  file: document.getElementById('csv_file'),
  fileErr: document.getElementById('csv_error'),

  analyzeBtn: document.getElementById('analyzeBtn'),
  startLargeBtn: document.getElementById('startLargeBtn'),
  resetBtn: document.getElementById('resetBtn'),

  status: document.getElementById('status'),
  diagWrap: document.getElementById('diagnostics'),
  diag: document.getElementById('diag-json'),

  progress: document.getElementById('progress'),
  progressFill: document.getElementById('progressFill'),

  counters: {
    total: document.getElementById('count-total'),
    processed: document.getElementById('count-processed'),
    matched: document.getElementById('count-matched'),
    skipped: document.getElementById('count-skipped')
  },

  results: document.getElementById('results'),
  downloadContainer: document.getElementById('downloadContainer'),

  helpBtn: document.getElementById('help'),
  userBadge: document.getElementById('user-badge'),
  userEmail: document.getElementById('user-email'),

  pbi: {
    dialog: document.getElementById('pbi-dialog'),
    form: document.getElementById('pbi-form'),
    openBtn: document.getElementById('importPbiBtn'),
    status: document.getElementById('pbi-status')
  },

  toggles: {
    intel: document.getElementById('toggle-intel')
  }
};

// ---------- Utilities ----------
function cid() {
  return (crypto.randomUUID && crypto.randomUUID()) || `${Date.now()}-${Math.random().toString(16).slice(2)}`;
}

async function fetchJson(url, opts = {}) {
  const correlationId = cid();
  const res = await fetch(url, {
    ...opts,
    headers: {
      ...(opts.headers || {}),
      'X-Correlation-Id': correlationId
    }
  });
  let body;
  try { body = await res.json(); } catch { body = await res.text(); }
  const resCid = res.headers.get('X-Correlation-Id') || correlationId;

  return { ok: res.ok, status: res.status, body, cid: resCid, res };
}

function setStatus(msg, level = 'info') {
  if (!els.status) return;
  els.status.textContent = msg || '';
  els.status.className = `status ${level}`;
}

function setDiag(obj) {
  if (!els.diag) return;
  els.diag.textContent = typeof obj === 'string' ? obj : JSON.stringify(obj, null, 2);
  if (els.diagWrap && !els.diagWrap.open) els.diagWrap.open = true;
}

function setProgress(pct = 0) {
  if (!els.progress || !els.progressFill) return;
  const clamped = Math.max(0, Math.min(100, pct));
  els.progress.hidden = clamped === 0 || clamped === 100 ? false : false; // keep visible during run
  els.progress.setAttribute('aria-hidden', 'false');
  els.progressFill.style.width = `${clamped}%`;
}

function setCounts({ total = 0, processed = 0, matched = 0, skipped = 0 } = {}) {
  const upd = (el, label, val) => { if (el) { el.dataset.count = String(val); el.textContent = `${label}: ${val}`; } };
  upd(els.counters.total, 'Total', total);
  upd(els.counters.processed, 'Processed', processed);
  upd(els.counters.matched, 'Matches', matched);
  upd(els.counters.skipped, 'Skipped', skipped);
}

function enableAnalyze(enabled) {
  if (!els.analyzeBtn) return;
  els.analyzeBtn.disabled = !enabled;
  els.analyzeBtn.classList.toggle('is-busy', false);
}

function showDownloadLink(href, text = 'Download CSV') {
  if (!els.downloadContainer) return;
  els.downloadContainer.innerHTML = '';
  const a = document.createElement('a');
  a.href = href;
  a.className = 'btn';
  a.textContent = text;
  a.setAttribute('download', '');
  els.downloadContainer.appendChild(a);
}

function clearDownload() {
  if (els.downloadContainer) els.downloadContainer.innerHTML = '';
}

function clearResults() {
  setCounts({ total: 0, processed: 0, matched: 0, skipped: 0 });
  setProgress(0);
  if (els.results) els.results.innerHTML = '';
  clearDownload();
  setStatus('');
  setDiag('');
}

// Quick CSV row counter (client-side) to decide small vs large run
async function countCsvRows(file) {
  const text = await file.text();
  // Count non-empty lines minus header
  const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
  return Math.max(0, lines.length - 1);
}

// ---------- Validation / state ----------
function validate() {
  let ok = true;
  if (els.evidenceTag && !els.evidenceTag.value.trim()) {
    ok = false;
    if (els.evidenceErr) els.evidenceErr.textContent = 'Please enter an evidence tag.';
  } else if (els.evidenceErr) {
    els.evidenceErr.textContent = '';
  }

  if (!els.file || !els.file.files || !els.file.files[0]) {
    ok = false;
    if (els.fileErr) els.fileErr.textContent = 'Please choose a CSV file.';
  } else if (els.fileErr) {
    els.fileErr.textContent = '';
  }

  enableAnalyze(ok);
  return ok;
}

async function updateAnalyzeState() {
  const ok = validate();
  if (!ok || !els.file?.files?.[0]) return;

  try {
    const rows = await countCsvRows(els.file.files[0]);
    // Small run: ≤ 50 rows; otherwise large
    if (rows > 50) {
      els.startLargeBtn?.removeAttribute('hidden');
      els.analyzeBtn?.setAttribute('disabled', 'true');
    } else {
      els.startLargeBtn?.setAttribute('hidden', 'true');
      enableAnalyze(true);
    }
    // Update total counter in UI
    setCounts({ total: rows, processed: 0, matched: 0, skipped: 0 });
  } catch {
    // If counting fails, keep defaults
  }
}

// ---------- Call type remember ----------
function loadCallType() {
  try {
    const saved = localStorage.getItem('ch.callType');
    if (saved && els.callType) els.callType.value = saved;
  } catch {}
  if (els.mapLabel) els.mapLabel.textContent = (els.callType?.value || 'Direct');
}

function persistCallTypeIfWanted() {
  if (!els.rememberCallType) return;
  try {
    if (els.rememberCallType.checked && els.callType?.value) {
      localStorage.setItem('ch.callType', els.callType.value);
    }
  } catch {}
}

// ---------- API flows ----------
async function runSmall() {
  if (!validate()) return;

  const fd = new FormData();
  fd.append('file', els.file.files[0]);
  fd.append('evidenceTag', els.evidenceTag.value.trim());
  fd.append('callType', els.callType?.value || '');

  clearResults();
  setStatus('Analyzing…');
  setProgress(5);
  els.analyzeBtn?.classList.add('is-busy');

  const { ok, status, body, cid } = await fetchJson(API_BASE, { method: 'POST', body: fd });

  els.analyzeBtn?.classList.remove('is-busy');

  if (!ok) {
    setStatus(`Analyze failed (${status}). CID=${cid}`, 'error');
    setDiag(body);
    console.error('Analyze failed', { status, body, cid });
    return;
  }

  // Expect either {counts, downloadUrl?} or a blob that triggers DL server-side
  try {
    if (body?.counts) {
      const { total = 0, processed = 0, matched = 0, skipped = 0 } = body.counts;
      setCounts({ total, processed, matched, skipped });
    }
    if (body?.downloadUrl) {
      showDownloadLink(body.downloadUrl);
    }
    setProgress(100);
    setStatus('Analyze complete');
    setDiag({ ok: true, cid, body });
  } catch (e) {
    setProgress(100);
    setStatus('Analyze complete (no extra details)');
    setDiag({ cid, note: 'Response parsed', error: String(e) });
  }
}

async function startLarge() {
  if (!validate()) return;

  const fd = new FormData();
  fd.append('file', els.file.files[0]);
  fd.append('evidenceTag', els.evidenceTag.value.trim());
  fd.append('callType', els.callType?.value || '');

  clearResults();
  setStatus('Starting large run…');
  setProgress(3);

  const { ok, status, body, cid } = await fetchJson(`${API_BASE}/start`, { method: 'POST', body: fd });

  if (!ok || !body?.jobId) {
    setStatus(`Start large run failed (${status}). CID=${cid}`, 'error');
    setDiag(body);
    console.error('Start large run failed', { status, body, cid });
    return;
  }

  const jobId = body.jobId;
  setStatus(`Job started: ${jobId}`);
  setDiag({ jobId, cid });

  // Poll status
  const started = Date.now();
  const poll = async () => {
    const { ok: okS, status: stS, body: bs, cid: scid } =
      await fetchJson(`${API_BASE}/status/${encodeURIComponent(jobId)}`);

    if (!okS) {
      setStatus(`Status error (${stS}). CID=${scid}`, 'error');
      setDiag(bs);
      return false; // stop on explicit error
    }

    // Expected status JSON: { state, progress, counts, downloadReady }
    if (typeof bs?.progress === 'number') setProgress(bs.progress);
    if (bs?.counts) {
      const { total = 0, processed = 0, matched = 0, skipped = 0 } = bs.counts;
      setCounts({ total, processed, matched, skipped });
    }
    if (bs?.state) setStatus(`Job ${jobId}: ${bs.state}`);

    if (bs?.downloadReady) {
      showDownloadLink(`${API_BASE}/download/${encodeURIComponent(jobId)}`);
      setStatus(`Job ${jobId}: ready`);
      setProgress(100);
      setDiag({ jobId, last: bs, cid: scid });
      return true; // done
    }

    // Soft timeout for dev (10 minutes)
    if (Date.now() - started > 10 * 60 * 1000) {
      setStatus(`Polling timed out for ${jobId}`, 'error');
      return true; // stop
    }

    return false; // continue
  };

  // initial poll immediately, then interval
  if (await poll()) return;
  const timer = setInterval(async () => {
    const done = await poll();
    if (done) clearInterval(timer);
  }, 1500);
}

// ---------- Wiring ----------
function wireForm() {
  if (!els.form) return;

  // Input listeners
  els.evidenceTag?.addEventListener('input', updateAnalyzeState);
  els.file?.addEventListener('change', updateAnalyzeState);
  els.callType?.addEventListener('change', () => {
    if (els.mapLabel) els.mapLabel.textContent = els.callType.value || 'Direct';
  });

  // Remember call type
  els.rememberCallType?.addEventListener('change', persistCallTypeIfWanted);

  // Buttons
  els.analyzeBtn?.addEventListener('click', (e) => { e.preventDefault(); runSmall().catch(console.error); });
  els.startLargeBtn?.addEventListener('click', (e) => { e.preventDefault(); startLarge().catch(console.error); });
  els.resetBtn?.addEventListener('click', () => {
    clearResults();
    enableAnalyze(false);
    els.startLargeBtn?.setAttribute('hidden', 'true');
    if (els.status) els.status.textContent = '';
    if (els.evidenceErr) els.evidenceErr.textContent = '';
    if (els.fileErr) els.fileErr.textContent = '';
  });

  // Initial disabled state until valid inputs
  enableAnalyze(false);
}

function wireHelp() {
  els.helpBtn?.addEventListener('click', () => {
    alert('This tool searches the Strategic Report for your evidence tag and returns matches. Upload a CSV, set a tag, then click Analyze or Start large run.');
  });
}

function wireToggles() {
  const { intel } = els.toggles;
  if (intel) {
    intel.addEventListener('click', () => {
      const body = document.getElementById('intel-body');
      const expanded = intel.getAttribute('aria-expanded') === 'true';
      intel.setAttribute('aria-expanded', String(!expanded));
      if (body) body.hidden = expanded;
    });
  }
}

async function loadUserBadge() {
  try {
    const r = await fetch('/.auth/me', { cache: 'no-store' });
    if (!r.ok) return;
    const data = await r.json();
    const email = data?.clientPrincipal?.userDetails || '';
    if (email && els.userBadge && els.userEmail) {
      els.userEmail.textContent = email;
      els.userBadge.classList.remove('is-hidden');
    }
  } catch {
    // ignore in local dev
  }
}

// ---------- Init ----------
function init() {
  loadCallType();
  wireForm();
  wireHelp();
  wireToggles();
  loadUserBadge();

  // Accessibility for status live region
  if (els.status) {
    els.status.setAttribute('aria-live', 'polite');
    els.status.setAttribute('aria-atomic', 'true');
  }
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init, { once: true });
} else {
  init();
}
