<!doctype html>
<html lang="en" data-app="inside-track-tools">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Inside Track Tools · Call scripts and emails(v2)</title>
  <link rel="stylesheet" href="./styles.css?v=2025-08-24-1">
</head>

<body>
  <!-- HEADER -->
  <header class="app-header" role="banner">
    <div class="header-left">
      <img class="logo" src="./assets/larato-logo-bullet.svg" alt="Larato Inside Track Sales Tools" />
      <div class="brand-text">
        <h1 class="app-title">Inside Track Tools</h1>
        <p class="kicker">Sales call scripting and emailing</p>
      </div>
    </div>
    <div class="header-right">
      <div class="calltype-mini" role="group" aria-labelledby="sales-model-label">
        <span id="sales-model-label" class="mini-label">Direct or partner sales</span>
        <select id="call_type" name="call_type" form="script-form" required aria-describedby="call_type_error">
          <option value="">Select…</option>
          <option>Direct</option>
          <option>Partner</option>
        </select>
        <label class="remember">
          <input type="checkbox" id="remember_call_type" form="script-form" /> Remember
        </label>
        <span id="call_type_error" class="error-inline" role="alert" aria-live="polite"></span>
      </div>

      <span class="model-note">
        <span class="label">Sales model in use:</span>
        <strong id="map-label">Direct</strong>
      </span>

      <button id="help" class="btn inline" type="button" title="About this tool">Help</button>

      <span id="user-badge" class="badge is-hidden" aria-live="polite" aria-atomic="true">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <circle cx="12" cy="7" r="4"></circle>
          <path d="M4 22c0-4 4-7 8-7s8 3 8 7"></path>
        </svg>
        <span id="user-email">Loading…</span>
      </span>
    </div>
  </header>

  <!-- LAYOUT -->
  <main id="main" class="layout" role="main">
    <!-- LEFT -->
    <section class="panel left" aria-label="Form">
      <form id="script-form" novalidate>
        <fieldset class="card" aria-labelledby="legend-call-details">
          <legend id="legend-call-details">Call details</legend>
          <div class="grid-2">
            <div class="field">
              <label for="seller_name">Your name <span aria-hidden="true" class="req">*</span></label>
              <input id="seller_name" name="seller_name" required autocomplete="name" />
              <p class="error" id="seller_name_error" role="alert" aria-live="polite"></p>
            </div>

            <!-- Mobile-only fallback for Sales model -->
            <div class="field field-calltype-xs">
              <label for="call_type_xs">Sales model <span aria-hidden="true" class="req">*</span></label>
              <select id="call_type_xs" name="call_type_xs" aria-describedby="call_type_error_xs">
                <option value="">Select…</option>
                <option>Direct</option>
                <option>Partner</option>
              </select>
              <p class="error" id="call_type_error_xs" role="alert" aria-live="polite"></p>
            </div>

            <div class="field">
              <label for="seller_company">Your company <span aria-hidden="true" class="req">*</span></label>
              <input id="seller_company" name="seller_company" required autocomplete="organization" />
              <p class="error" id="seller_company_error" role="alert" aria-live="polite"></p>
            </div>

            <div class="field">
              <label for="prospect_name">Prospect name <span aria-hidden="true" class="req">*</span></label>
              <input id="prospect_name" name="prospect_name" required />
              <p class="error" id="prospect_name_error" role="alert" aria-live="polite"></p>
            </div>

            <div class="field">
              <label for="prospect_role">Prospect role <span aria-hidden="true" class="req">*</span></label>
              <input id="prospect_role" name="prospect_role" required placeholder="e.g., Finance Director" />
              <p class="error" id="prospect_role_error" role="alert" aria-live="polite"></p>
            </div>

            <div class="field">
              <label for="prospect_company">Prospect company <span aria-hidden="true" class="req">*</span></label>
              <input id="prospect_company" name="prospect_company" required />
              <p class="error" id="prospect_company_error" role="alert" aria-live="polite"></p>
            </div>
          </div>
        </fieldset>

        <fieldset class="card" aria-labelledby="legend-targeting">
          <legend id="legend-targeting">Targeting</legend>
          <div class="grid-2">
            <div class="field">
              <label for="product">Product <span aria-hidden="true" class="req">*</span></label>
              <select id="product" name="product" required>
                <option value="">Loading…</option>
              </select>
              <p class="error" id="product_error" role="alert" aria-live="polite"></p>
            </div>

            <div class="field">
              <label for="buyer_behaviour">Buyer behaviour <span aria-hidden="true" class="req">*</span></label>
              <select id="buyer_behaviour" name="buyer_behaviour" required>
                <option value="">Select…</option>
                <option>Innovator</option>
                <option>Early adopter</option>
                <option>Early majority</option>
                <option>Late majority</option>
                <option>Sceptic</option>
              </select>
              <p class="error" id="buyer_behaviour_error" role="alert" aria-live="polite"></p>
            </div>
          </div>
        </fieldset>

        <fieldset class="card" aria-labelledby="legend-preferences">
          <legend id="legend-preferences">Script preferences</legend>
          <div class="grid-2">
            <div class="field">
              <label for="tone">Tone</label>
              <select id="tone" name="tone">
                <option selected>Professional (corporate)</option>
                <option>Warm (professional)</option>
              </select>
            </div>

            <div class="field">
              <label for="script_length">Length</label>
              <select id="script_length" name="script_length">
                <option>~150 words</option>
                <option selected>~300 words</option>
                <option>~450 words</option>
                <option>~650 words</option>
              </select>
            </div>
          </div>

          <div class="field">
            <label for="value_proposition">Unique Selling Points (optional)</label>
            <textarea id="value_proposition" name="value_proposition" rows="2"
              placeholder="e.g., pooled data; contract portability; self-serve provisioning"></textarea>
          </div>

          <div class="field">
            <label for="context">Other points to cover (optional)</label>
            <textarea id="context" name="context" rows="3"
              placeholder="Any specific themes you want woven into the call (comma, semicolon or new line separated)."></textarea>
          </div>

          <div class="field">
            <label for="next_step">Your desired next step</label>
            <input id="next_step" name="next_step"
              placeholder="e.g., I’ll send a 1-page summary and we can pick it up from there." />
          </div>
        </fieldset>

        <div class="actions">
          <button id="submit" class="btn primary" type="submit" disabled>
            <span class="btn-label">Go</span>
            <span class="spinner" aria-hidden="true"></span>
          </button>
          <button id="resetBtn" type="reset" form="callForm" class="btn small">Reset</button>
        </div>

        <div id="status" class="status" role="status" aria-live="polite"></div>

        <details id="diagnostics" class="diag card" style="margin-top:var(--s-5)">
          <summary>Diagnostics</summary>
          <pre id="diag-json" tabindex="0" aria-label="Diagnostics JSON"></pre>
          <p class="muted">If you see a 401 unauthorised error, please <a href="/.auth/login/aad">sign in again</a>.</p>
        </details>
      </form>
    </section>

    <!-- MIDDLE -->
    <section class="panel middle">
      <div class="row-between output-head">
        <h2 id="output-title">Conversation Guide</h2>
        <div class="row-between" style="gap:8px">
          <button id="toggle-bullets" class="btn inline" type="button" aria-pressed="false">Show bullet point
            script</button>
          <button id="popout" class="btn inline" type="button" title="Open script in a clean window">Pop-out</button>
          <div class="meta" id="output-meta" aria-live="polite" style="color:var(--text-2);font-size:.9rem"></div>
        </div>
      </div>

      <div id="output" class="output" tabindex="0" aria-label="Generated script will appear here"></div>

      <!-- Output actions under the script -->
      <div class="output-actions">
        <button id="copy-script" class="btn inline" type="button" disabled>Copy script</button>
        <button id="download-script" class="btn inline" type="button" disabled>Download script</button>

        <!-- NEW: highlighter controls -->
        <button id="toggle-highlighter" class="btn inline" type="button" aria-pressed="false">Highlighter</button>
        <button id="clear-highlights" class="btn inline" type="button">Clear highlights</button>
      </div>

      <!-- Notes under the output -->
      <div class="notes-card card" style="margin-top:var(--s-4)">
        <div class="row-between">
          <h3>Call notes</h3>
          <div class="row-between" style="gap:8px">
            <button id="save-notes" class="btn inline" type="button">Save notes</button>
            <button id="download-notes" class="btn inline" type="button">Download .txt</button>
            <button id="make-followup" class="btn inline" type="button">Create follow-up email</button>
          </div>
        </div>
        <textarea id="notes" rows="6"
          placeholder="Type notes during the call. Saved locally on this device."></textarea>
        <p class="muted" style="margin-top:.5rem">Notes are stored locally (this browser only).</p>
      </div>

      <div class="change-log" style="margin-top:var(--s-4)">
        <h3>What changed</h3>
        <ul id="delta-log" class="delta" aria-live="polite"></ul>
      </div>
      <div class="activity" style="margin-top:var(--s-4)">
        <h3>Recent activity</h3>
        <ol id="activity-log" class="activity-log" aria-live="polite" style="margin:0;padding-left:1.25rem"></ol>
      </div>
    </section>

    <!-- Script Pop-out Modal -->
    <dialog id="script-modal" class="modal">
      <button id="close-modal" class="btn">Close ×</button>
      <div id="modal-script" class="output" style="min-height:auto"></div>
    </dialog>

    <!-- Help Modal -->
    <dialog id="help-modal" class="modal">
      <div class="card" style="max-width:700px">
        <div class="row-between" style="align-items:center">
          <h3 style="margin:0">About this tool</h3>
          <button id="help-close" class="btn inline" type="button">Close ×</button>
        </div>
        <p>This Sales call scripting and emailing tool is designed to save you time. In just a minute, you can prepare a
          sharp,
          buyer-centred conversation guide for sales calls, and then turn your call notes into a concise follow-up
          email. Scripts and emails blend your inputs (prospect, product, USPs, context and desired next step) with our
          call-library
          templates and current buyer intelligence to produce high quality sales content fast.</p>

        <h3>How to use it</h3>
        <ol>
          <li><strong>Set the sales model:</strong> choose <em>Direct</em> or <em>Partner</em> at the top.</li>
          <li><strong>Complete Call details:</strong> your name/company and the prospect’s name, role and company.</li>
          <li><strong>Targeting:</strong> pick the <em>Product</em> and <em>Buyer behaviour</em>. The <em>Buyer
              needs</em> panel on the right updates to match.</li>
          <li><strong>Script preferences:</strong> choose tone and length. Add:
            <ul>
              <li><strong>Unique Selling Points</strong> – the core advantages you want emphasised.</li>
              <li><strong>Other points to cover</strong> – any extra themes or constraints.</li>
              <li><strong>Your desired next step</strong> – if you have a preferred CTA.</li>
            </ul>
          </li>
          <li><strong>Generate script:</strong> click <em>Generate script</em>. The <em>Conversation Guide</em> appears
            in the middle, with clear sections (Opening, Buyer Pain, Buyer Desire, Example, Objections, Next Step).</li>
          <li><strong>Use it:</strong> copy or download the script using the buttons under the guide. The tips card
            gives three quick coaching pointers.</li>
          <li><strong>During the call:</strong> type into <em>Call notes</em> (saved locally in your browser).</li>
          <li><strong>After the call:</strong> click <em>Create follow-up email</em> to generate a short, crisp email
            that stitches together your script and notes.</li>
        </ol>

        <h3>What the tool assures</h3>
        <ul>
          <li>These tools save you time and assure that every call you make is the best it could be.</li>
          <li>All scripts follow proven best practice sales methods focused on delivering value to the prospect in ways
            that build trust and lead to well qualified opportunities.</li>
          <li>You can choose from a professoinal, more corporate tone of language, or a warmer one if you prefer.</li>
          <li>Uses your Next step if provided. If not, it uses the follow up from the researched sales pitches that are
            centred on what prospects have said they would value.</li>
          <li>The scripts produced are an elegant blend of your requirements for the call and the researched sales
            pitches.</li>
        </ul>

        <h3>Where the insights come from</h3>
        <p>Buyer information and behaviours are refreshed monthly. The underlying sales pitches are researched every six
          months across
          technology buyers and indirect channel players. Together, this gives you a gold-standard view
          of current commercial status, pains, priorities, triggers, proof points, objections and CTAs for each buyer
          behaviour.</p>

        <h3>Tips for best results</h3>
        <ul>
          <li>Be specific in USPs (e.g., “Starlink for remote sites; pooled mobile data across teams”).</li>
          <li>Use <em>Other points</em> for constraints (timelines, budget signals, existing suppliers) to steer the
            tone.</li>
          <li>Always enter a practical <em>Next step</em> if you have one; it takes precedence.</li>
        </ul>

        <h3>Privacy & storage</h3>
        <ul>
          <li><em>Call notes</em> are stored locally in your browser only.</li>
          <li>The script is generated server-side; if you see a 401 error, sign in again via the Diagnostics link.</li>
        </ul>

        <h3>Troubleshooting</h3>
        <ul>
          <li>If a required field is missing, the status bar will say what to complete.</li>
          <li>If generation fails, open <em>Diagnostics</em> to view the error and try again.</li>
          <li>Product list empty? Check you’ve selected the correct sales model (Direct/Partner).</li>
        </ul>

        <h3>Feedback</h3>
        <p>We want these tools to be the best for you. If you have ideas for improvements or suggestions that would make
          this even more valuable to you, please contact us through our website.</p>
      </div>
    </dialog>

    <!-- RIGHT -->
    <section class="panel right" aria-labelledby="helpers-title">

      <!-- Helpers title (same style as Conversation Guide) -->
      <div class="row-between output-head">
        <h2 id="helpers-title">Helpers</h2>
      </div>

      <!-- Buyer needs (UNCHANGED look; still collapsible) -->
      <aside class="intel card">
        <div class="intel-head">
          <h2 id="intel-title">Buyer needs</h2>
          <button id="toggle-intel" class="btn small" type="button" aria-expanded="false"
            aria-controls="intel-body">Show</button>
        </div>
        <div id="intel-body" hidden>
          <div class="intel-grid">
            <section>
              <h3>1) Buyer Priorities</h3>
              <div id="intel-priorities" class="intel-slot"></div>
            </section>
            <section>
              <h3>2) Typical Pains</h3>
              <div id="intel-pains" class="intel-slot"></div>
            </section>
            <section>
              <h3>3) Triggers</h3>
              <div id="intel-triggers" class="intel-slot"></div>
            </section>
            <section>
              <h3>4) Value Proof</h3>
              <div id="intel-proof" class="intel-slot"></div>
            </section>
            <section>
              <h3>5) Objections</h3>
              <div id="intel-objections" class="intel-slot"></div>
            </section>
            <section>
              <h3>6) CTAs</h3>
              <div id="intel-ctas" class="intel-slot"></div>
            </section>
          </div>
        </div>
      </aside>

      <!-- Call opener ideas (NEW — looks like Buyer needs) -->
      <aside class="intel card" style="margin-top:var(--s-4)">
        <div class="intel-head">
          <h2 id="openers-title">Call opener ideas</h2>
          <button id="toggle-openers" class="btn small" type="button" aria-expanded="false"
            aria-controls="openers-body">Show</button>
        </div>

        <div id="openers-body" hidden>
          <ul id="openers-list"></ul>
        </div>
      </aside>

      <!-- Helpful tips (RESTYLED to match Buyer needs) -->
      <aside class="intel card" style="margin-top:var(--s-4)">
        <div class="intel-head">
          <h2 id="tips-title">Helpful tips</h2>
          <button id="toggle-tips" class="btn small" type="button" aria-expanded="true"
            aria-controls="tips-body">Hide</button>
        </div>
        <div id="tips-body">
          <ul id="tips-list"></ul>
        </div>
      </aside>
    </section>
  </main>

  <template id="activity-item">
    <li>
      <span class="time"></span>
      <span class="pill product"></span>
      <span class="pill buyer"></span>
      <span class="pill length"></span>
    </li>
  </template>

  <!-- === SCRIPT === -->
  <script type="module">
    import { getIndex, loadTemplate, canonical } from "./src/lib/callLibrary.js?v=fix6";

    /* basePrefix for subpath hosting */
    const basePrefix = (() => {
      const parts = (location.pathname || "").split("/");
      const last = parts[parts.length - 1] || "";
      if (last.includes(".")) return "";
      return parts.length > 1 && parts[1] ? `/${parts[1]}` : "";
    })();

    // State shared by views (keep on window for pop-out)
    let bulletMode = false;
    let highlightMode = false;
    let lastRender = { html: "", bulletsHtml: "" };
    window.bulletMode = bulletMode;
    window.lastRender = lastRender;

    // Small helpers
    const esc = s => String(s || "").replace(/[&<>]/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;" }[c]));
    const strongify = s => String(s || "").replace(/\*\*([^\*\n][\s\S]*?)\*\*/g, "<strong>$1</strong>");

    // Canon/aliases
    const REQUIRED_CANON = ["Opening", "Buyer Pain", "Buyer Desire", "Example Illustration", "Handling Objections", "Next Step"];
    const SECTION_ALIASES = {
      "Opening": ["opening", "introduction", "overview"],
      "Buyer Pain": ["buyer pain", "pains", "pain", "challenges", "problems"],
      "Buyer Desire": ["buyer desire", "desire", "goals", "objectives", "what they want"],
      "Example Illustration": ["example illustration", "example", "case study", "illustration"],
      "Handling Objections": ["handling objections", "objections", "objection handling"],
      "Next Step": ["next step", "next steps", "call to action", "cta"]
    };
    // UI-only heading overrides (logic still uses canonical names)
    const DISPLAY_LABELS = {
      "Opening": "Overview"
      // add more if you ever want: "Buyer Pain": "Problems", etc.
    };

    const PREFACE = {
      title: "About this guide",
      body: `This guide gives you a head start by distilling the buyer’s likely pains and desired outcomes into a simple conversation plan with evidence, plus clear responses to common objections. It’s a shortcut, not a script. Use it to open stronger, ask sharper questions, earn trust quickly and secure a clear next step.`
    };

    /* Normalise + parse markdown into sections */
    function normaliseMd(raw) {
      return String(raw || "")
        .replace(/\r/g, "")
        .replace(/\s*##\s+/g, "\n\n## ")
        .replace(/(?:^|[^\n])\s-\s(?=\S)/g, m => (m.endsWith("- ") ? m : m.replace(/\s-\s/, "\n- ")))
        .replace(/[ \t]+\n/g, "\n")
        .trim();
    }
    function parseSections(raw) {
      const s = normaliseMd(raw);
      const lines = s.split("\n");
      const sections = [];
      let current = null;
      const pushCurrent = () => { if (current && (current.paras.length || current.list.length)) sections.push(current); };
      const start = t => { if (current) pushCurrent(); current = { title: t, paras: [], list: [] }; };

      const CANON = new Map([
        ["opening", "Opening"],
        ["buyer pain", "Buyer Pain"], ["pains", "Buyer Pain"], ["pain", "Buyer Pain"],
        ["buyer desire", "Buyer Desire"], ["desire", "Buyer Desire"], ["goals", "Buyer Desire"],
        ["example illustration", "Example Illustration"], ["example", "Example Illustration"], ["case study", "Example Illustration"],
        ["handling objections", "Handling Objections"], ["objections", "Handling Objections"],
        ["next step", "Next Step"], ["next steps", "Next Step"], ["call to action", "Next Step"], ["cta", "Next Step"],
      ]);
      const HEADING_RX = /^(?:#{2,}\s*|\*\*\s*|__\s*)?(opening|buyer pain|buyer desire|example illustration|handling objections|objections|next step|next steps|call to action|cta)\b[:\s-]*?(.*)$/i;

      const firstNonEmpty = lines.find(l => l.trim());
      if (firstNonEmpty) {
        const m0 = firstNonEmpty.trim().match(HEADING_RX);
        const canon0 = m0 ? CANON.get((m0[1] || "").toLowerCase().trim()) : null;
        if (!canon0) start("Opening");
      }

      for (const rawLine of lines) {
        const line = rawLine.trim();
        if (!line) continue;

        const m = line.match(HEADING_RX);
        if (m) {
          const canon = CANON.get((m[1] || "").toLowerCase().trim());
          if (canon) {
            pushCurrent();
            current = { title: canon, paras: [], list: [] };
            const rest = (m[2] || "").trim();
            if (rest) current.paras.push(rest);
            continue;
          }
        }
        if (line.startsWith("- ")) { if (!current) start("Opening"); current.list.push(line.slice(2).trim()); continue; }
        if (!current) start("Opening");
        current.paras.push(line);
      }
      pushCurrent();
      return sections;
    }

    function commonBlock(node) {
      // restrict to a single paragraph OR list item (keeps HTML valid)
      const el = node?.nodeType === 3 ? node.parentElement : node;
      return el?.closest?.('p, li') || null;
    }

    function highlightCurrentSelection() {
      const sel = window.getSelection();
      if (!sel || sel.isCollapsed || sel.rangeCount === 0) return;

      const range = sel.getRangeAt(0);
      // only allow highlights inside the script output
      if (!outputEl.contains(range.commonAncestorContainer)) return;

      const a = commonBlock(sel.anchorNode);
      const b = commonBlock(sel.focusNode);
      if (!a || !b || a !== b) {
        setStatus('Select within a single paragraph or bullet to highlight.', 'error');
        sel.removeAllRanges();
        return;
      }

      // Wrap selection contents safely
      const r = range.cloneRange();
      const frag = r.extractContents();
      const mark = document.createElement('mark');
      mark.className = 'hl';
      mark.appendChild(frag);
      r.insertNode(mark);

      // clear selection and confirm
      sel.removeAllRanges();
      setStatus('Highlighted.');
    }

    function clearHighlights() {
      outputEl.querySelectorAll('mark.hl').forEach(m => {
        const parent = m.parentNode;
        while (m.firstChild) parent.insertBefore(m.firstChild, m);
        parent.removeChild(m);
        parent.normalize();
      });
      setStatus('Highlights cleared.');
    }

    /* Render sections -> HTML */
    function renderSectionsToHtml(rawMd, valuesForFallback) {
      // local fallbacks to avoid external deps
      const escapeRxLocal = (typeof escapeRx === "function")
        ? escapeRx
        : (s => String(s || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
      const labelForFn = (typeof labelFor === "function") ? labelFor : (s => s);
      const PREF = (typeof PREFACE === "object" && PREFACE) ? PREFACE : {};

      const sections = parseSections(rawMd);
      const byKey = new Map(sections.map(s => [String(s.title).toLowerCase(), s]));

      // Build a regex for the auto-greeting so we can strip it from "Opening"
      const v = valuesForFallback || {};
      const greetRx = (() => {
        const pn = (v.prospect_name || "").trim();
        const sn = (v.seller_name || "").trim();
        const sc = (v.seller_company || "").trim();
        if (!pn || !sn || !sc) return null;
        return new RegExp(
          `^hello\\s+${escapeRxLocal(pn)}\\s*,?\\s+it[’']?s\\s+${escapeRxLocal(sn)}\\s+from\\s+${escapeRxLocal(sc)}\\.?$`,
          "i"
        );
      })();

      const getByAliases = (canonName) => {
        const aliases = SECTION_ALIASES[canonName] || [canonName];
        for (const a of aliases) {
          const key = String(a).toLowerCase();
          if (byKey.has(key)) return byKey.get(key);
          for (const [k, v] of byKey.entries()) {
            if (k.includes(key) || key.includes(k)) return v;
          }
        }
        return null;
      };

      const blocks = [];
      const found = [];
      const missing = [];

      for (const canonName of REQUIRED_CANON) {
        const sec = getByAliases(canonName);

        if (sec) {
          // Strip auto-greeting line from Opening, if present
          if (/^opening$/i.test(sec.title) && greetRx) {
            sec.paras = (sec.paras || []).filter(p => !greetRx.test(String(p).trim()));
          }

          const body = [
            ...(sec.paras || []).map(p => `<p>${strongify(esc(p))}</p>`),
            ...(sec.list && sec.list.length
              ? [`<ul>${sec.list.map(li => `<li>${strongify(esc(li))}</li>`).join("")}</ul>`]
              : [])
          ].join("");

          found.push(canonName);
          blocks.push(
            `<section class="script-sec"><h3>${esc(labelForFn(canonName))}</h3>${body}</section>`
          );
        } else {
          // Missing section rendering
          missing.push(canonName);
          if (canonName === "Next Step") {
            const nx = v?.next_step || "";
            const pHtml = nx
              ? `<p>${strongify(esc(nx))}</p>`
              : `<p class="muted">Not provided in the generated script.</p>`;
            blocks.push(
              `<section class="script-sec is-missing"><h3>${esc(labelForFn("Next Step"))}</h3>${pHtml}</section>`
            );
          } else {
            blocks.push(
              `<section class="script-sec is-missing"><h3>${esc(labelForFn(canonName))}</h3><p class="muted">Not provided in the generated script.</p></section>`
            );
          }
        }
      }

      // Preface block (only if body text exists)
      const prefaceHtml = PREF?.body
        ? `<section class="script-sec preface">
        <h3>${esc(PREF.title || "About this guide")}</h3>
        <p>${strongify(esc(PREF.body))}</p>
      </section>`
        : "";

      // Prepend preface before the first canonical section
      return {
        html: `<div class="script-body">${prefaceHtml}${blocks.join("")}</div>`,
        found,
        missing,
        sections
      };
    }


    const labelFor = (canon) => (DISPLAY_LABELS[canon] || canon);

    /* Bullet view (kept for future) */
    function firstSentence(s, max = 220) { const txt = String(s || "").replace(/\s+/g, " ").trim(); if (!txt) return ""; const m = txt.match(/^(.{1,220}?[.!?])(\s|$)/); return (m ? m[1] : txt.slice(0, max)).trim(); }
    function sentencesWithNumbers(s, limit = 2) { const parts = String(s || "").split(/(?<=[.!?])\s+/); const hits = parts.filter(x => /\b(\d{1,3}(,\d{3})*|\d+%|£\d+)/.test(x)); return hits.slice(0, limit).map(x => x.trim()); }
    function renderBulletScriptFromSections(sections) {
      const by = Object.create(null); for (const s of sections) by[(s.title || "").toLowerCase()] = s;
      const bullets = [];
      if (by["opening"]) { const t = firstSentence(by["opening"].paras.join(" ").trim() || by["opening"].list[0] || ""); if (t) bullets.push(t); }
      if (by["buyer pain"]) { if (by["buyer pain"].list.length) bullets.push(...by["buyer pain"].list.slice(0, 3)); else { const t = firstSentence(by["buyer pain"].paras.join(" ").trim()); if (t) bullets.push(t); } }
      if (by["buyer desire"]) { if (by["buyer desire"].list.length) bullets.push(...by["buyer desire"].list.slice(0, 3)); else { const t = firstSentence(by["buyer desire"].paras.join(" ").trim()); if (t) bullets.push(t); } }
      if (by["example illustration"]) { const para = by["example illustration"].paras.join(" ").trim(); const metricLines = sentencesWithNumbers(para, 2); if (metricLines.length) bullets.push(...metricLines); else { const t = firstSentence(para); if (t) bullets.push("Example: " + t); } }
      if (by["handling objections"]) { if (by["handling objections"].list.length) bullets.push(...by["handling objections"].list.slice(0, 3)); else { const t = firstSentence(by["handling objections"].paras.join(" ").trim()); if (t) bullets.push("Objections: " + t); } }
      if (by["next step"]) { const t = firstSentence((by["next step"].paras.join(" ") || by["next step"].list.join("; ")).trim()); if (t) bullets.push("Next step: " + t); }
      const items = bullets.map(b => `<li>${esc(b)}</li>`).join("");
      return `<div class="script-body"><h3>Bullet point script</h3><ul>${items || "<li>No bulletable content found.</li>"}</ul></div>`;
    }

    /* Keys */
    const FORM_ID = 'script-form';
    const STORAGE_KEY = 'first_call_script_v2.form';
    const ACTIVITY_KEY = 'first_call_script_v2.activity';
    const OUTPUT_KEY = 'first_call_script_v2.last_output';
    const CALL_PREF_KEY = 'first_call_script_v2.call_pref';
    const TIPS_HIDDEN_KEY = 'first_call_script_v2.tips_hidden';
    const OPENERS_HIDDEN_KEY = 'first_call_script_v2.openers_hidden';
    // One-time reset so openers start hidden after this deploy
    const OPENERS_PREF_VERSION = '2';
    try {
      const vkey = 'first_call_script_v2.openers_pref_version';
      if (localStorage.getItem(vkey) !== OPENERS_PREF_VERSION) {
        localStorage.setItem(OPENERS_HIDDEN_KEY, '1'); // 1 = hidden, 0 = shown
        localStorage.setItem(vkey, OPENERS_PREF_VERSION);
      }
    } catch { }

    const NOTES_KEY_PREFIX = 'first_call_script_v2.notes';
    const INTEL_URL = './intel.json';

    const REQUIRED = ['call_type', 'seller_name', 'seller_company', 'prospect_name', 'prospect_role', 'prospect_company', 'buyer_behaviour', 'product'];

    // Refs
    const form = document.getElementById(FORM_ID);
    const submitBtn = document.getElementById('submit');
    const resetBtn = document.getElementById('resetBtn');
    const outputEl = document.getElementById('output');
    const copyScriptBtn = document.getElementById('copy-script');
    const downloadScriptBtn = document.getElementById('download-script');
    const tipsList = document.getElementById('tips-list');
    const toggleTipsBtn = document.getElementById('toggle-tips');
    const openersList = document.getElementById('openers-list');
    const toggleOpenersBtn = document.getElementById('toggle-openers');
    const tipsBody = document.getElementById('tips-body'); // new wrapper for Helpful tips body
    const popoutBtn = document.getElementById('popout');
    const notesArea = document.getElementById('notes');
    const saveNotesBtn = document.getElementById('save-notes');
    const downloadNotesBtn = document.getElementById('download-notes');
    const outputMeta = document.getElementById('output-meta');
    const statusEl = document.getElementById('status');
    const deltaLog = document.getElementById('delta-log');
    const activityLog = document.getElementById('activity-log');
    const activityTpl = document.getElementById('activity-item');
    const diag = document.getElementById('diagnostics');
    const diagJson = document.getElementById('diag-json');
    const modal = document.getElementById('script-modal');
    const closeModal = document.getElementById('close-modal');
    const modalScript = document.getElementById('modal-script');
    const productSel = document.getElementById('product');
    const buyerBehSel = document.getElementById('buyer_behaviour');
    const toggleIntelBtn = document.getElementById('toggle-intel');
    const intelBody = document.getElementById('intel-body');
    const callTypeSel = document.getElementById('call_type');
    const callTypeSelXs = document.getElementById('call_type_xs');
    const rememberCallType = document.getElementById('remember_call_type');
    const mapLabel = document.getElementById('map-label');
    const helpBtn = document.getElementById('help');
    const helpModal = document.getElementById('help-modal');
    const helpClose = document.getElementById('help-close');
    const userBadge = document.getElementById('user-badge');
    const userEmail = document.getElementById('user-email');
    const toggleHighlighterBtn = document.getElementById('toggle-highlighter');
    const clearHighlightsBtn = document.getElementById('clear-highlights');
    const modeFromCallType = v => canonical.mode(v);
    const buyerCanon = v => canonical.buyer(v);
    const nowTime = () => new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    // Default Buyer needs to collapsed on first load
    if (toggleIntelBtn && intelBody) {
      toggleIntelBtn.setAttribute('aria-expanded', 'false');
      toggleIntelBtn.textContent = 'Show';
      intelBody.hidden = true;
    }

    if (closeModal) closeModal.addEventListener("click", () => modal.close());
    if (helpBtn) helpBtn.addEventListener('click', () => helpModal?.showModal());
    if (helpClose) helpClose.addEventListener('click', () => helpModal?.close());

    toggleHighlighterBtn?.addEventListener('click', () => {
      highlightMode = !highlightMode;
      toggleHighlighterBtn.setAttribute('aria-pressed', String(highlightMode));
      setStatus(highlightMode ? 'Highlighter on — select text in the guide.' : 'Highlighter off.');
    });

    clearHighlightsBtn?.addEventListener('click', clearHighlights);

    // Create a highlight when user selects text and releases the mouse
    outputEl?.addEventListener('mouseup', () => {
      if (highlightMode) highlightCurrentSelection();
    });

    // Optional: ESC turns the highlighter off
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && highlightMode) {
        highlightMode = false;
        toggleHighlighterBtn?.setAttribute('aria-pressed', 'false');
        setStatus('Highlighter off.');
      }
    });

    function setBusy(isBusy) {
      if (submitBtn) submitBtn.disabled = isBusy || !allRequiredFilled(form);
      if (resetBtn) resetBtn.disabled = isBusy;
      const hasText = !!(outputEl?.textContent?.trim());
      if (copyScriptBtn) copyScriptBtn.disabled = isBusy || !hasText;
      if (downloadScriptBtn) downloadScriptBtn.disabled = isBusy || !hasText;
      if (submitBtn) submitBtn.classList.toggle('busy', isBusy);
    }
    function setStatus(msg, kind = 'info') { if (!statusEl) return; statusEl.textContent = msg; statusEl.dataset.kind = kind; }

    function allRequiredFilled(formEl) {
      if (!formEl) return false;
      const labels = { call_type: 'Direct or partner sales', seller_name: 'Your name', seller_company: 'Your company', prospect_name: 'Prospect name', prospect_role: 'Prospect role', prospect_company: 'Prospect company', buyer_behaviour: 'Buyer behaviour', product: 'Product' };
      const missing = [];
      const getVal = (name) => {
        if (name === 'product') return (productSel?.value || '').trim();
        if (name === 'buyer_behaviour') return (buyerBehSel?.value || '').trim();
        if (name === 'call_type') return (callTypeSel?.value || '').trim();
        return (formEl.elements[name]?.value || '').trim();
      };
      for (const name of REQUIRED) { const val = getVal(name); if (!val) missing.push(labels[name] || name); }
      if (missing.length) setStatus(`Please complete: ${missing.join(', ')}.`, 'error'); else setStatus('');
      return missing.length === 0;
    }
    function refreshSubmitState() { if (submitBtn) submitBtn.disabled = !allRequiredFilled(form); }

    function validateField(input) {
      if (!input) return;
      const el = (typeof input === 'string') ? (form.elements[input] || document.getElementById(input)) : input;
      if (!el) return;
      const id = el.id || el.name || '';
      const errorEl = document.getElementById(`${id}_error`) || (id === 'call_type' ? document.getElementById('call_type_error') : null);
      let value = '';
      if (id === 'product') value = (productSel.value || '').trim();
      else if (id === 'buyer_behaviour') value = (buyerBehSel.value || '').trim();
      else if (id === 'call_type') value = (callTypeSel?.value || '').trim();
      else value = (el.value || '').trim();
      const valid = !!value;
      if (!errorEl) return;
      if (valid) { errorEl.textContent = ''; el.removeAttribute('aria-invalid'); el.classList.remove('invalid'); }
      else { errorEl.textContent = id === 'call_type' ? 'Please choose a call type.' : 'This field is required.'; el.setAttribute('aria-invalid', 'true'); el.classList.add('invalid'); }
    }

    function saveForm() { if (!form) return; const fd = Object.fromEntries(new FormData(form).entries()); localStorage.setItem(STORAGE_KEY, JSON.stringify(fd)); }
    function loadForm() {
      const raw = localStorage.getItem(STORAGE_KEY); if (!raw) return;
      try { const data = JSON.parse(raw); Object.entries(data).forEach(([k, v]) => { const el = form.elements[k] || document.getElementById(k); if (el) el.value = v; }); } catch { }
    }

    // Notes
    const notesKey = () => { const pn = (form?.elements?.prospect_name?.value || '').trim().toLowerCase(); const pc = (form?.elements?.prospect_company?.value || '').trim().toLowerCase(); return `${NOTES_KEY_PREFIX}::${pc}::${pn}` || NOTES_KEY_PREFIX; };
    function loadNotes() { try { notesArea.value = localStorage.getItem(notesKey()) || ''; } catch { } }
    function saveNotes() { try { localStorage.setItem(notesKey(), notesArea.value || ''); setStatus('Notes saved.'); } catch (e) { setStatus('Could not save notes.', 'error'); } }
    function downloadText(filename, text) { const blob = new Blob([text], { type: 'text/plain' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); URL.revokeObjectURL(url); a.remove(); }

    // Buyer needs
    const norm = s => String(s || '').toLowerCase().trim();
    const toArr = v => Array.isArray(v) ? v.filter(Boolean).map(String) : (v ? [String(v)] : []);
    function getKeyInsensitive(obj, requested) {
      if (!obj || typeof obj !== 'object') return null;
      const want = norm(requested).replace(/\s+/g, '-');
      for (const k of Object.keys(obj)) if (norm(k).replace(/\s+/g, '-') === want) return k;
      for (const k of Object.keys(obj)) if (norm(k).includes(norm(requested))) return k;
      return null;
    }
    const pEl = t => { const el = document.createElement('p'); el.textContent = t; return el; };
    const setSlot = (id, arr = []) => { const slot = document.getElementById(id); const items = (arr.length ? arr : ['No data available for this selection.']); if (slot) slot.replaceChildren(...items.map(pEl)); };
    const fillAll = arr => { setSlot('intel-priorities', arr); setSlot('intel-pains', arr); setSlot('intel-triggers', arr); setSlot('intel-proof', arr); setSlot('intel-objections', arr); setSlot('intel-ctas', arr); };

    function normaliseIntel(raw) {
      if (!raw || typeof raw !== 'object') return { products: {} };
      if (raw.products && typeof raw.products === 'object') return raw;
      const out = { products: {} };
      Object.entries(raw).forEach(([product, buyersObj]) => {
        const behaviours = {};
        if (buyersObj && typeof buyersObj === 'object') {
          Object.entries(buyersObj).forEach(([behaviour, arr]) => {
            const [priorities, pains, triggers, proof, objections, ctas] = Array.isArray(arr) ? arr : [];
            behaviours[behaviour] = { priorities: toArr(priorities), pains: toArr(pains), triggers: toArr(triggers), proof: toArr(proof), objections: toArr(objections), ctas: toArr(ctas) };
          });
        }
        out.products[product] = { behaviours };
      });
      return out;
    }

    let intel = null;
    function renderIntel(productLabel, behaviourLabel) {
      if (!intel) return;
      const products = intel.products || {};
      const productKey = getKeyInsensitive(products, productLabel);
      const productNode = productKey ? products[productKey] : null;
      if (!productNode) { fillAll(['No data available (unknown product).']); return; }
      const pool = productNode.behaviours || productNode.buyers || {};
      const key = getKeyInsensitive(pool, behaviourLabel);
      const node = key ? pool[key] : (productNode.needs || null);
      if (!node) {
        const behavioursList = [...Object.keys(productNode.behaviours || {}), ...Object.keys(productNode.buyers || {})].join(', ') || '—';
        fillAll([`No data for this behaviour. Available: ${behavioursList}`]); return;
      }
      const sections = {
        priorities: toArr(node?.priorities ?? node?.Priorities),
        pains: toArr(node?.pains ?? node?.Pains),
        triggers: toArr(node?.triggers ?? node?.Triggers),
        proof: toArr(node?.proof ?? node?.Proof ?? node?.value ?? node?.Value),
        objections: toArr(node?.objections ?? node?.Objections),
        ctas: toArr(node?.ctas ?? node?.CTAs ?? node?.callsToAction ?? node?.CallsToAction)
      };
      const allEmpty = Object.values(sections).every(a => a.length === 0);
      if (allEmpty) { fillAll(['No data available for this selection.']); return; }
      setSlot('intel-priorities', sections.priorities);
      setSlot('intel-pains', sections.pains);
      setSlot('intel-triggers', sections.triggers);
      setSlot('intel-proof', sections.proof);
      setSlot('intel-objections', sections.objections);
      setSlot('intel-ctas', sections.ctas);
    }

    // Activity / delta
    function addActivity(entry) {
      const list = JSON.parse(localStorage.getItem(ACTIVITY_KEY) || '[]');
      list.unshift(entry); localStorage.setItem(ACTIVITY_KEY, JSON.stringify(list.slice(0, 3))); renderActivity();
    }
    function renderActivity() {
      const list = JSON.parse(localStorage.getItem(ACTIVITY_KEY) || '[]');
      if (!activityLog) return; activityLog.innerHTML = '';
      list.forEach(item => {
        const node = activityTpl.content.cloneNode(true);
        node.querySelector('.time').textContent = item.time;
        node.querySelector('.product').textContent = item.product;
        node.querySelector('.buyer').textContent = item.buyer_behaviour || item.buyer || '';
        node.querySelector('.length').textContent = item.length || '';
        activityLog.appendChild(node);
      });
    }
    function computeDelta(oldText, newText) {
      const oldLines = (oldText || '').split('\n'), newLines = (newText || '').split('\n');
      let added = 0, removed = 0;
      const oldSet = new Set(oldLines), newSet = new Set(newLines);
      newLines.forEach(l => { if (!oldSet.has(l) && l.trim()) added++; });
      oldLines.forEach(l => { if (!newSet.has(l) && l.trim()) removed++; });
      return { added, removed };
    }
    function renderDelta(delta) {
      if (!deltaLog) return;
      deltaLog.innerHTML = '';
      const a = document.createElement('li'); a.textContent = `+${delta.added} new line${delta.added === 1 ? '' : 's'}`;
      const r = document.createElement('li'); r.textContent = `−${delta.removed} removed line${delta.removed === 1 ? '' : 's'}`;
      deltaLog.appendChild(a); deltaLog.appendChild(r);
    }

    // Header chip / remember
    function loadCallPref() {
      try {
        const pref = JSON.parse(localStorage.getItem(CALL_PREF_KEY) || 'null');
        if (pref?.call_type && callTypeSel && !callTypeSel.value) callTypeSel.value = pref.call_type;
        if (pref?.remember === true && rememberCallType) rememberCallType.checked = true;
      } catch { }
      updateMapIndicator();
    }
    function saveCallPrefIfRequested() {
      if (rememberCallType && rememberCallType.checked && callTypeSel && callTypeSel.value) {
        localStorage.setItem(CALL_PREF_KEY, JSON.stringify({ remember: true, call_type: callTypeSel.value }));
      } else if (rememberCallType && !rememberCallType.checked) {
        localStorage.removeItem(CALL_PREF_KEY);
      }
      updateMapIndicator();
    }
    function updateMapIndicator() {
      const pref = JSON.parse(localStorage.getItem(CALL_PREF_KEY) || 'null');
      if (mapLabel) mapLabel.textContent = pref?.call_type || (callTypeSel?.value || 'Not set');
    }

    // Assets for Call opener ideas
    const OPENERS_URL_JSON = './assets/call-opener-ideas.json';
    const OPENERS_URL_TXT = './assets/call-opener-ideas.txt';

    async function loadOpenersFromAssets() {
      // Try JSON first
      try {
        const rj = await fetch(OPENERS_URL_JSON, { cache: 'no-store' });
        if (rj.ok) {
          const arr = await rj.json();
          const tips = (Array.isArray(arr) ? arr : []).map(s => String(s).trim()).filter(Boolean);
          if (tips.length) return tips.slice(0, 3);
        }
      } catch { }

      // Fallback to TXT (one per line)
      try {
        const rt = await fetch(OPENERS_URL_TXT, { cache: 'no-store' });
        if (rt.ok) {
          const t = await rt.text();
          const tips = t.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
          if (tips.length) return tips.slice(0, 3);
        }
      } catch { }

      return [];
    }

    function renderOpeners(list) {
      if (!openersList) return;
      openersList.innerHTML = '';

      const items = (list && list.length) ? list.slice(0, 3) : [
        'Add up to 3 ideas in ./assets/call-opener-ideas.json or .txt'
      ];

      items.forEach(t => {
        const li = document.createElement('li');
        li.textContent = t;
        if (!list || !list.length) li.className = 'muted';
        openersList.appendChild(li);
      });
    }

    function applyOpenersVisibility() {
      const openersBody = document.getElementById('openers-body');
      const btn = document.getElementById('toggle-openers');
      if (!openersBody || !btn) return;

      // default to hidden when there's no stored choice yet
      const stored = localStorage.getItem(OPENERS_HIDDEN_KEY);
      const hidden = (stored === null) ? true : stored === '1';

      openersBody.hidden = hidden;
      btn.textContent = hidden ? 'Show' : 'Hide';
      btn.setAttribute('aria-expanded', String(!hidden));
    }

    // Tips toggle + auto-hide (works for any tip source)
    function applyTipsVisibility() {
      const body = document.getElementById('tips-body');   // new wrapper div around the list
      if (!body || !tipsList || !toggleTipsBtn) return;

      // Respect user's choice
      const hidden = localStorage.getItem(TIPS_HIDDEN_KEY) === '1';
      body.hidden = hidden;
      toggleTipsBtn.textContent = hidden ? 'Show' : 'Hide';
      toggleTipsBtn.setAttribute('aria-expanded', String(!hidden));

      // Placeholder when there are no tips yet (kept from your original behaviour)
      const hasTips = tipsList.children.length > 0;
      let empty = document.getElementById('tips-empty');

      if (!hasTips) {
        if (!empty) {
          empty = document.createElement('p');
          empty.id = 'tips-empty';
          empty.className = 'muted';
          empty.textContent = 'More tips for this conversation will be offered after you generate your guide.';
          // place after the list but still inside the body wrapper
          tipsList.insertAdjacentElement('afterend', empty);
        }
      } else if (empty) {
        empty.remove();
      }
    }

    // Events
    const onChangeRecalcIntel = () => {
      const label = productSel?.options?.[productSel.selectedIndex]?.text ?? productSel?.value ?? '';
      renderIntel(label, buyerBehSel?.value || '');
    };

    callTypeSel?.addEventListener('change', async () => {
      if (callTypeSelXs) callTypeSelXs.value = callTypeSel.value;
      validateField(callTypeSel);
      saveForm(); updateMapIndicator(); refreshSubmitState();
      const mode = modeFromCallType(callTypeSel.value) || 'direct';
      await populateProductsForMode(mode);
      validateField('product');
    });

    // Recalculate Buyer needs when Product or Buyer behaviour changes
    productSel?.addEventListener('change', () => {
      validateField('product');
      saveForm();
      onChangeRecalcIntel();
    });

    buyerBehSel?.addEventListener('change', () => {
      validateField('buyer_behaviour');
      saveForm();
      onChangeRecalcIntel();
    });

    // Mobile mirror (async to use await)
    callTypeSelXs?.addEventListener('change', async () => {
      if (!callTypeSel) return;
      callTypeSel.value = callTypeSelXs.value;
      validateField(callTypeSel);
      saveForm(); updateMapIndicator(); refreshSubmitState();
      const mode = modeFromCallType(callTypeSel.value) || 'direct';
      await populateProductsForMode(mode);
      callTypeSel.dispatchEvent(new Event('change', { bubbles: true }));
    });

    document.getElementById('toggle-intel')?.addEventListener('click', () => {
      const expanded = toggleIntelBtn.getAttribute('aria-expanded') === 'true';
      toggleIntelBtn.setAttribute('aria-expanded', String(!expanded));
      if (intelBody) intelBody.hidden = expanded;
      toggleIntelBtn.textContent = expanded ? 'Show' : 'Hide';
    });


    toggleTipsBtn?.addEventListener('click', () => {
      const hidden = localStorage.getItem(TIPS_HIDDEN_KEY) === '1';
      localStorage.setItem(TIPS_HIDDEN_KEY, hidden ? '0' : '1');
      applyTipsVisibility();
    });

    toggleOpenersBtn?.addEventListener('click', () => {
      const raw = localStorage.getItem(OPENERS_HIDDEN_KEY);
      const currentlyHidden = (raw === null) ? true : (raw === '1');
      localStorage.setItem(OPENERS_HIDDEN_KEY, currentlyHidden ? '0' : '1');
      applyOpenersVisibility();
    });

    saveNotesBtn?.addEventListener('click', saveNotes);
    downloadNotesBtn?.addEventListener('click', () => {
      const who = (form?.elements?.prospect_name?.value || 'prospect').trim().replace(/\s+/g, '-');
      downloadText(`call-notes_${who}_${new Date().toISOString().slice(0, 10)}.txt`, notesArea.value || '');
    });

    // New Copy/Download under the script
    copyScriptBtn?.addEventListener('click', async () => {
      const txt = outputEl?.innerText || ''; if (!txt.trim()) return;
      await navigator.clipboard.writeText(txt); setStatus('Copied script to clipboard.');
    });
    downloadScriptBtn?.addEventListener('click', () => {
      const txt = outputEl?.innerText || ''; if (!txt.trim()) return;
      const who = (form?.elements?.prospect_name?.value || 'script').trim().replace(/\s+/g, '-');
      downloadText(`conversation-guide_${who}_${new Date().toISOString().slice(0, 10)}.txt`, txt);
    });

    // Product registry
    async function populateProductsForMode(mode) {
      const sel = document.getElementById('product');
      if (!sel) return;
      sel.innerHTML = `<option value="">Loading…</option>`;
      try {
        const idx = await getIndex(mode, basePrefix);
        const items = Array.isArray(idx?.products) ? idx.products : Array.isArray(idx?.items) ? idx.items : Array.isArray(idx) ? idx : [];
        if (!items.length) { sel.innerHTML = `<option value="">No products found</option>`; console.warn('[Product] index.json loaded but empty', idx); return; }
        const saved = (form?.elements?.product?.value || '').trim().toLowerCase();
        sel.innerHTML = '<option value="" disabled>Select…</option>';
        for (const item of items) {
          const idLike = item.id ?? item.slug ?? item.value ?? item.key ?? item.name ?? item.label;
          const label = item.label ?? item.name ?? String(idLike ?? '');
          const val = String(idLike || '').trim().toLowerCase().replace(/\s+/g, '-');
          if (!val) continue;
          const opt = document.createElement('option'); opt.value = val; opt.textContent = label;
          if (saved && (saved === val || saved === String(label).toLowerCase())) opt.selected = true;
          sel.appendChild(opt);
        }
        if (!sel.value) sel.options[0].selected = true;
        validateField(sel);
        if (buyerBehSel?.value) {
          const label = sel?.options?.[sel.selectedIndex]?.text || sel.value || '';
          renderIntel(label, buyerBehSel.value);
        }
        refreshSubmitState();
      } catch (err) {
        console.error('[Product] Failed to load index.json', err);
        sel.innerHTML = `<option value="">Error loading products</option>`;
        setStatus('Could not load products index. See console for details.', 'error');
      }
    }

    // Submit: API-first
    form && form.addEventListener("submit", async (e) => {
      e.preventDefault();
      for (const name of REQUIRED) {
        const el = form.elements[name] || document.getElementById(name);
        if (!el || !String(el.value || "").trim()) { validateField(el); el?.focus(); setStatus("Please complete required fields.", "error"); return; }
      }

      const values = {
        call_type: (callTypeSel?.value || "").trim(),
        seller_name: (form.elements.seller_name?.value || "").trim(),
        seller_company: (form.elements.seller_company?.value || "").trim(),
        prospect_name: (form.elements.prospect_name?.value || "").trim(),
        prospect_role: (form.elements.prospect_role?.value || "").trim(),
        prospect_company: (form.elements.prospect_company?.value || "").trim(),
        product: (productSel?.value || form.elements.product?.value || "").trim(),
        buyer_behaviour: (buyerBehSel?.value || form.elements.buyer_behaviour?.value || "").trim(),
        tone: (form.elements.tone?.value || "").trim(),
        script_length: (form.elements.script_length?.value || "").trim(),
        value_proposition: (form.elements.value_proposition?.value || "").trim(),
        context: (form.elements.context?.value || "").trim(),
        next_step: (form.elements.next_step?.value || "").trim(),
      };

      const mode = modeFromCallType(values.call_type);
      const productId = String(values.product).toLowerCase().trim();
      const buyerId = buyerCanon(values.buyer_behaviour);
      if (!productId) { validateField("product"); setStatus("Please choose a product.", "error"); return; }

      setBusy(true); setStatus("Generating call script…");
      if (diag) diag.open = false; if (diagJson) diagJson.textContent = "";

      try {
        const mdUrl = `${basePrefix}/content/call-library/v1/${mode}/${productId}/${buyerId}.md`;
        let templateText = "";
        try { const res = await fetch(mdUrl, { cache: "no-store" }); if (res.ok) templateText = await res.text(); } catch { }
        const body = {
          kind: "call-script",
          basePrefix,
          variables: { ...values, mode, product: productId, buyerType: buyerId },
          templateMdText: templateText
        };

        const resp = await fetch("/api/generate", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(body) });
        if (!resp.ok) { const errTxt = await resp.text(); throw new Error(`API ${resp.status}: ${errTxt}`); }

        const data = await resp.json();
        const script = data?.script?.text || "";
        const tips = data?.script?.tips || [];
        if (!script || !script.trim()) throw new Error("Empty script returned from API");

        const escapeRx = s => String(s || "").replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        const rendered = renderSectionsToHtml(script, values);
        const bulletsHtml = renderBulletScriptFromSections(rendered.sections);
        lastRender = { html: rendered.html, bulletsHtml }; window.lastRender = lastRender;

        const htmlToShow = bulletMode ? bulletsHtml : rendered.html;
        outputEl.innerHTML = htmlToShow;
        modalScript.innerHTML = htmlToShow;

        outputMeta.textContent = `Library · ${productSel?.options?.[productSel.selectedIndex]?.text || productId} · ${values.buyer_behaviour || "—"} · ${values.call_type || "—"}`;

        // Tips
        tipsList.innerHTML = ""; (tips || []).forEach(t => { const li = document.createElement("li"); li.textContent = t; tipsList.appendChild(li); });
        applyTipsVisibility();

        // Load and render Call opener ideas (defaults to hidden)
        try {
          const openerTips = await loadOpenersFromAssets();
          renderOpeners(openerTips);
        } catch { }
        applyOpenersVisibility();

        // Enable copy/download now there is content
        copyScriptBtn.disabled = false; downloadScriptBtn.disabled = false;

        // Delta + activity
        const old = localStorage.getItem(OUTPUT_KEY) || "";
        const delta = computeDelta(old, script);
        renderDelta(delta);
        localStorage.setItem(OUTPUT_KEY, script);

        addActivity({ time: nowTime(), product: productId, buyer_behaviour: values.buyer_behaviour || "—", length: values.length || "—" });

        setStatus("Done. (Generated from API)");
        setBusy(false);
        document.getElementById("output-title")?.focus();
      } catch (err) {
        setStatus("Could not generate a call script. See Diagnostics for details.", "error");
        if (diag) { diag.open = true; diagJson.textContent = String(err?.message || err); }
        setBusy(false);
      }
    });

    // Follow-up email
    document.getElementById('make-followup')?.addEventListener('click', async () => {
      try {
        const payload = {
          kind: 'call-followup',
          basePrefix,
          variables: {
            seller_name: (form.elements.seller_name?.value || "").trim(),
            seller_company: (form.elements.seller_company?.value || "").trim(),
            prospect_name: (form.elements.prospect_name?.value || "").trim(),
            prospect_role: (form.elements.prospect_role?.value || "").trim(),
            prospect_company: (form.elements.prospect_company?.value || "").trim(),
            tone: (form.elements.tone?.value || "").trim(),
          },
          scriptMdText: localStorage.getItem('first_call_script_v2.last_output') || "",
          callNotes: (notesArea?.value || "")
        };
        setStatus('Building follow-up email…');
        const r = await fetch('/api/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        const data = await r.json();
        if (!r.ok) throw new Error(data?.error || 'Could not build follow-up');
        modalScript.innerText = data?.followup?.email || 'No email produced.';
        modal.showModal();
        setStatus('Follow-up ready.');
      } catch (e) {
        setStatus('Could not build follow-up email', 'error');
        diag.open = true; diagJson.textContent = String(e?.message || e);
      }
    });

    // Pop-out (kept but hidden via CSS)
    if (popoutBtn) {
      popoutBtn.onclick = () => {
        const meta = (document.getElementById('output-meta')?.textContent || '').trim();
        const html = (window.bulletMode && window.lastRender?.bulletsHtml) || (window.lastRender?.html) || (outputEl?.innerHTML || "");
        if (!html || !html.trim()) { setStatus("No script to pop out yet.", "error"); return; }
        const w = window.open("", "_blank", "noopener,noreferrer");
        if (!w) { setStatus("Pop-out was blocked by the browser.", "error"); return; }
        w.document.open();
        w.document.write(`<!doctype html>
<meta charset="utf-8"><title>Conversation Guide</title>
<style>
  body{font:16.5px/1.65 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial;padding:20px;background:#fff;color:#111}
  .meta{color:#6b7280;font-size:.9rem;margin-bottom:10px}
  .bar{display:flex;gap:8px;align-items:center;justify-content:flex-end;margin-bottom:8px}
  button{padding:.35rem .55rem;border:1px solid #e5e7eb;border-radius:8px;background:#f9fafb;cursor:pointer}
</style>
<div class="bar"><button onclick="window.print()">Print</button>
<button onclick="navigator.clipboard.writeText(document.body.innerText)">Copy</button></div>
<div class="meta">${esc(meta)}</div>
<div>${html}</div>`);
        w.document.close();
      };
    }

    // Unified reset handler — runs AFTER native form reset completes
    form?.addEventListener('reset', () => {
      // Let the browser restore default values first
      queueMicrotask(() => {
        try {
          // If you mirror the sales model in two selects, sync them
          if (typeof callTypeSelXs !== 'undefined' && typeof callTypeSel !== 'undefined') {
            callTypeSelXs.value = callTypeSel.value || '';
          }

          // Clear persisted state
          try { localStorage.removeItem(STORAGE_KEY); } catch { }
          try { localStorage.removeItem(ACTIVITY_KEY); } catch { }
          try { localStorage.removeItem(OUTPUT_KEY); } catch { }
          try { localStorage.removeItem(notesKey?.() ?? ''); } catch { }

          // Wipe UI surfaces
          outputEl && (outputEl.innerHTML = '');
          tipsList && (tipsList.innerHTML = '');
          activityLog && (activityLog.innerHTML = '');
          deltaLog && (deltaLog.innerHTML = '');
          statusEl && (statusEl.textContent = '');
          copyScriptBtn && (copyScriptBtn.disabled = true);
          downloadScriptBtn && (downloadScriptBtn.disabled = true);

          // Notes (textarea or contenteditable fallback)
          if (notesArea) {
            if ('value' in notesArea) notesArea.value = '';
            else notesArea.textContent = '';
          }

          // Remove any validation styling
          form.querySelectorAll('.invalid')?.forEach(el => el.classList.remove('invalid'));

          // Reset any derived placeholders
          typeof fillAll === 'function' && fillAll(['—']);

          // Recompute submit-state
          typeof refreshSubmitState === 'function' && refreshSubmitState();

          // Make sure left column is scrolled to top and focus first field
          document.querySelector('.panel.left')?.scrollTo({ top: 0, behavior: 'instant' });
          document.getElementById('seller_name')?.focus();

          // Reapply tips visibility after UI wipe
          typeof applyTipsVisibility === 'function' && applyTipsVisibility();
        } catch (e) {
          typeof setStatus === 'function' && setStatus('Could not reset form.', 'error');
        }
      });
    });


    // Init
    (async function init() {
      try {
        const me = await fetch('/.auth/me', { cache: 'no-store' });
        const j = await me.json();
        const email = j?.clientPrincipal?.userDetails || j?.clientPrincipal?.identityProvider || '';
        if (email && userBadge && userEmail) { userEmail.textContent = email; userBadge.classList.remove('is-hidden'); }
      } catch { }

      // Buyer needs preload
      try { const res = await fetch(INTEL_URL, { cache: 'no-store' }); intel = normaliseIntel(await res.json()); }
      catch { intel = { products: {} }; }

      loadForm(); loadCallPref();
      if (callTypeSelXs && callTypeSel) { callTypeSelXs.value = callTypeSel.value || ''; }

      const currentMode = modeFromCallType(callTypeSel?.value || 'direct');
      await populateProductsForMode(currentMode);
      if (productSel?.value && buyerBehSel?.value) {
        const label = productSel?.options?.[productSel.selectedIndex]?.text ?? productSel?.value ?? '';
        renderIntel(label, buyerBehSel.value);
      }

      applyTipsVisibility();
      const hasText = !!(outputEl?.textContent?.trim());
      copyScriptBtn.disabled = !hasText;
      downloadScriptBtn.disabled = !hasText;
      submitBtn.disabled = !allRequiredFilled(form);
      loadNotes();

      // Load Call opener ideas (defaults hidden; button shows "Show")
      try {
        const openerTips = await loadOpenersFromAssets();
        renderOpeners(openerTips);
      } catch { }
      applyOpenersVisibility();

      document.addEventListener('input', (e) => {
        if (e.target.closest('#' + FORM_ID)) { validateField(e.target); saveForm(); refreshSubmitState(); }
        if (e.target === callTypeSel) saveCallPrefIfRequested();
      });
    })();
  </script>
</body>

</html>