<script type="module">
  import { getIndex, getCallScript, canonical } from "/src/lib/callLibrary.js";

  (function () {
    /* =========================================================================
       Constants & element refs
       ========================================================================= */
    const FORM_ID = 'script-form';
    const STORAGE_KEY = 'first_call_script_v2.form';
    const ACTIVITY_KEY = 'first_call_script_v2.activity';
    const OUTPUT_KEY = 'first_call_script_v2.last_output';
    const CALL_PREF_KEY = 'first_call_script_v2.call_pref';
    const INTEL_URL = '/src/intel.json'; // intel lives under /src

    const REQUIRED = [
      'call_type','seller_name','seller_company',
      'prospect_name','prospect_role','prospect_company',
      'buyer_behaviour','product'
    ];

    const form = document.getElementById(FORM_ID);
    const submitBtn = document.getElementById('submit');
    const resetBtn = document.getElementById('reset');
    const copyBtn = document.getElementById('copy');
    const downloadBtn = document.getElementById('download');
    const outputEl = document.getElementById('output');
    const outputMeta = document.getElementById('output-meta');
    const statusEl = document.getElementById('status');
    const deltaLog = document.getElementById('delta-log');
    const activityLog = document.getElementById('activity-log');
    const activityTpl = document.getElementById('activity-item');
    const diag = document.getElementById('diagnostics');
    const diagJson = document.getElementById('diag-json');

    const productSel = document.getElementById('product');
    const buyerBehSel = document.getElementById('buyer_behaviour');
    const toggleIntelBtn = document.getElementById('toggle-intel');
    const intelBody = document.getElementById('intel-body');

    const callTypeSel = document.getElementById('call_type');
    const rememberCallType = document.getElementById('remember_call_type');
    const mapLabel = document.getElementById('map-label');

    let lastOutput = localStorage.getItem(OUTPUT_KEY) || '';
    let intel = null;

    /* =========================================================================
       Utilities & accessibility helpers
       ========================================================================= */
    const nowTime = () => new Date().toLocaleTimeString([], { hour:'2-digit', minute:'2-digit', second:'2-digit' });
    const prefersReducedMotion = () => window.matchMedia('(prefers-reduced-motion: reduce)').matches;

    function setBusy(isBusy) {
      submitBtn.disabled = isBusy || !allRequiredFilled(form);
      resetBtn.disabled = isBusy;
      const hasText = !!outputEl.textContent.trim();
      copyBtn.disabled = isBusy || !hasText;
      downloadBtn.disabled = isBusy || !hasText;
      submitBtn.classList.toggle('busy', isBusy);
    }
    function setStatus(msg, kind='info') { statusEl.textContent = msg; statusEl.dataset.kind = kind; }

    function allRequiredFilled(formEl) {
      const missing = [];
      const label = {
        call_type:'Direct or partner sales', seller_name:'Your name', seller_company:'Your company',
        prospect_name:'Prospect name', prospect_role:'Prospect role', prospect_company:'Prospect company',
        buyer_behaviour:'Buyer behaviour', product:'Product'
      };
      for (const name of REQUIRED) {
        const el = formEl.elements[name] || document.getElementById(name);
        const val = (el && typeof el.value === 'string') ? el.value.trim() : '';
        if (!val) missing.push(label[name] || name);
      }
      if (missing.length) setStatus(`Please complete: ${missing.join(', ')}.`, 'error'); else setStatus('');
      return missing.length === 0;
    }
    function refreshSubmitState(){ submitBtn.disabled = !allRequiredFilled(form); }

    function validateField(input) {
      const id = input.id;
      const errorEl = document.getElementById(`${id}_error`) || (id==='call_type' ? document.getElementById('call_type_error') : null);
      if (!errorEl) return;
      const valid = !!String(input.value || '').trim();
      if (valid) { errorEl.textContent=''; input.removeAttribute('aria-invalid'); input.classList.remove('invalid'); }
      else { errorEl.textContent = id==='call_type' ? 'Please choose a call type.' : 'This field is required.'; input.setAttribute('aria-invalid','true'); input.classList.add('invalid'); }
    }

    // Save/restore state (include header control value)
    function saveForm() {
      const fd = Object.fromEntries(new FormData(form).entries());
      fd.call_type = callTypeSel.value || fd.call_type || '';
      localStorage.setItem(STORAGE_KEY, JSON.stringify(fd));
    }
    function loadForm() {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        Object.entries(data).forEach(([k,v]) => {
          const el = form.elements[k] || document.getElementById(k);
          if (el) el.value = v;
        });
      } catch {}
    }
    function clearFormState() { localStorage.removeItem(STORAGE_KEY); localStorage.removeItem(ACTIVITY_KEY); }

    /* =========================================================================
       Buyer needs helpers (unchanged)
       ========================================================================= */
    const toArr = v => Array.isArray(v) ? v.filter(Boolean).map(String) : (v ? [String(v)] : []);
    const norm = s => String(s || '').toLowerCase().replace(/\s+/g,' ').replace(/[\u2010-\u2015_\-\/]+/g,'-').replace(/[^\w\- ]+/g,'').trim();
    const BEHAVIOUR_SYNONYMS = { 'early adopter':'early-adopter','early majority':'early-majority','late majority':'late-majority','skeptic':'sceptic','sceptic':'sceptic' };
    function getKeyInsensitive(obj, requested){
      if (!obj || typeof obj !== 'object') return null;
      const want = norm(requested);
      for (const k of Object.keys(obj)) if (norm(k) === want) return k;
      for (const k of Object.keys(obj)) if (norm(k).includes(want)) return k;
      return null;
    }
    const pEl = t => { const el=document.createElement('p'); el.textContent=t; return el; };
    const setSlot = (id, arr=[]) => {
      const slot=document.getElementById(id);
      const items=(arr.length?arr:['No data for this selection.']);
      slot.replaceChildren(...items.map(pEl));
    };
    const fillAll = arr => {
      setSlot('intel-priorities', arr); setSlot('intel-pains', arr); setSlot('intel-triggers', arr);
      setSlot('intel-proof', arr); setSlot('intel-objections', arr); setSlot('intel-ctas', arr);
    };
    function normaliseIntel(raw){
      if (!raw || typeof raw !== 'object') return { products:{} };
      if (raw.products && typeof raw.products === 'object') return raw;
      const out = { products:{} };
      Object.entries(raw).forEach(([product, buyersObj]) => {
        const behaviours = {};
        if (buyersObj && typeof buyersObj === 'object') {
          Object.entries(buyersObj).forEach(([behaviour, arr]) => {
            const [priorities, pains, triggers, proof, objections, ctas] = Array.isArray(arr) ? arr : [];
            behaviours[behaviour] = { priorities: toArr(priorities), pains: toArr(pains), triggers: toArr(triggers), proof: toArr(proof), objections: toArr(objections), ctas: toArr(ctas) };
          });
        }
        out.products[product] = { behaviours };
      });
      return out;
    }
    function renderIntel(productLabel, behaviourLabel){
      if (!intel) return;
      const products = intel.products || {};
      const productKey = getKeyInsensitive(products, productLabel);
      const productNode = productKey ? products[productKey] : null;
      if (!productNode){ fillAll([`No data available (unknown product).`]); return; }

      let node = null;
      if (productNode.behaviours){
        let key = getKeyInsensitive(productNode.behaviours, behaviourLabel);
        if (!key){ const syn = BEHAVIOUR_SYNONYMS[norm(behaviourLabel)]; if (syn) key = getKeyInsensitive(productNode.behaviours, syn); }
        if (key) node = productNode.behaviours[key];
      }
      if (!node && productNode.buyers){
        let key = getKeyInsensitive(productNode.buyers, behaviourLabel);
        if (!key){ const syn = BEHAVIOUR_SYNONYMS[norm(behaviourLabel)]; if (syn) key = getKeyInsensitive(productNode.buyers, syn); }
        if (key) node = productNode.buyers[key];
      }
      if (!node && productNode.needs) node = productNode.needs;

      if (!node){
        const behavioursList = [...Object.keys(productNode.behaviours || {}), ...Object.keys(productNode.buyers || {})].join(', ') || '—';
        fillAll([`No data for this behaviour. Available: ${behavioursList}`]);
        return;
      }

      const sections = {
        priorities: toArr(node?.priorities ?? node?.Priorities),
        pains:      toArr(node?.pains      ?? node?.Pains),
        triggers:   toArr(node?.triggers   ?? node?.Triggers),
        proof:      toArr(node?.proof      ?? node?.Proof ?? node?.value ?? node?.Value),
        objections: toArr(node?.objections ?? node?.Objections),
        ctas:       toArr(node?.ctas       ?? node?.CTAs  ?? node?.callsToAction ?? node?.CallsToAction)
      };

      const allEmpty = Object.values(sections).every(a => a.length === 0);
      if (allEmpty){ fillAll(['No data available for this selection.']); return; }

      setSlot('intel-priorities', sections.priorities);
      setSlot('intel-pains',      sections.pains);
      setSlot('intel-triggers',   sections.triggers);
      setSlot('intel-proof',      sections.proof);
      setSlot('intel-objections', sections.objections);
      setSlot('intel-ctas',       sections.ctas);
    }

    // Use the label from the <select> (intel.json uses human names)
    const getSelectedProductLabel = () =>
      productSel.options[productSel.selectedIndex]?.text || productSel.value || '';

    // Tiny heuristic for reminders from generated text
    function extractKeyPoints(text){
      const sentences = String(text).split(/(?<=[.!?])\s+/).map(s=>s.trim()).filter(Boolean);
      const keywords = /(reduce|save|cut|improv|increase|risk|cost|time|secure|resilien|revenue|margin|efficien|customer|cx|compliance|ml|ai|automate|protect)/i;
      const scored = sentences.map(s => {
        let score = 0;
        score += (s.match(/[,;:]/g)||[]).length;
        if (keywords.test(s)) score += 3;
        if (s.length >= 60 && s.length <= 180) score += 2;
        if (/we|you|your|let's/i.test(s)) score += 1;
        return { s, score };
      }).sort((a,b)=>b.score-a.score);
      return (scored.length?scored:sentences).slice(0,3).map(o=>o.s);
    }
    function injectRemindersFromScript(text){
      const points = extractKeyPoints(text);
      if (!points.length) return;
      setSlot('intel-priorities', ['From your script:', points[0] || '']);
      setSlot('intel-pains',      ['Reminder:', points[1] || '']);
      setSlot('intel-triggers',   ['Keep in mind:', points[2] || '']);
    }

    /* =========================================================================
       Activity / delta log
       ========================================================================= */
    function addActivity(entry) {
      const list = JSON.parse(localStorage.getItem(ACTIVITY_KEY) || '[]');
      list.unshift(entry);
      localStorage.setItem(ACTIVITY_KEY, JSON.stringify(list.slice(0,3)));
      renderActivity();
    }
    function renderActivity() {
      const list = JSON.parse(localStorage.getItem(ACTIVITY_KEY) || '[]');
      activityLog.innerHTML = '';
      list.forEach(item => {
        const node = activityTpl.content.cloneNode(true);
        node.querySelector('.time').textContent = item.time;
        node.querySelector('.product').textContent = item.product;
        node.querySelector('.buyer').textContent = item.buyer_behaviour;
        node.querySelector('.length').textContent = item.length;
        activityLog.appendChild(node);
      });
    }
    function computeDelta(oldText, newText) {
      const oldLines = (oldText||'').split('\n'), newLines = (newText||'').split('\n');
      let added = 0, removed = 0;
      const oldSet = new Set(oldLines), newSet = new Set(newLines);
      newLines.forEach(l => { if (!oldSet.has(l) && l.trim()) added++; });
      oldLines.forEach(l => { if (!newSet.has(l) && l.trim()) removed++; });
      return { added, removed };
    }
    function renderDelta(delta) {
      deltaLog.innerHTML = '';
      const a = document.createElement('li'); a.textContent = `+${delta.added} new line${delta.added===1?'':'s'}`;
      const r = document.createElement('li'); r.textContent = `−${delta.removed} removed line${delta.removed===1?'':'s'}`;
      deltaLog.appendChild(a); deltaLog.appendChild(r);
    }

    // Badge hydration
    async function hydrateUserBadge() {
      const el = document.getElementById('user-badge');
      try {
        const res = await fetch('/.auth/me', { credentials: 'include' });
        if (!res.ok) throw new Error(String(res.status));
        const data = await res.json();
        const claim = data?.clientPrincipal?.userDetails || 'Signed in';
        el.querySelector('span:last-child').textContent = claim;
        el.classList.remove('is-hidden');
      } catch (e) {
        el.innerHTML = 'Not signed in — <a href="/.auth/login/aad">Sign in</a>';
        el.classList.remove('is-hidden');
      }
    }

    /* =========================================================================
       Events
       ========================================================================= */
    ['change','input','blur'].forEach(evt => {
      callTypeSel.addEventListener(evt, () => {
        validateField(callTypeSel);
        saveForm();
        updateMapIndicator();
        refreshSubmitState();
      });
      rememberCallType.addEventListener(evt, () => {
        saveCallPrefIfRequested();
        refreshSubmitState();
      });
    });

    ['input','change','blur'].forEach(evt => {
      form.addEventListener(evt, (e) => {
        if (e.target.matches('input,select,textarea')) {
          validateField(e.target);
          saveForm();
          refreshSubmitState();
        }
        if (e.type==='change' && (e.target === productSel || e.target === buyerBehSel)) {
          // intel.json expects human label
          renderIntel(getSelectedProductLabel(), buyerBehSel.value);
        }
      }, true);
    });

    toggleIntelBtn.addEventListener('click', () => {
      const expanded = toggleIntelBtn.getAttribute('aria-expanded') === 'true';
      toggleIntelBtn.setAttribute('aria-expanded', String(!expanded));
      intelBody.hidden = expanded;
      toggleIntelBtn.textContent = expanded ? 'Show' : 'Hide';
    });

    document.getElementById('reset').addEventListener('click', () => {
      form.reset(); clearFormState();
      setStatus('Form reset.');
      renderIntel(getSelectedProductLabel(), buyerBehSel.value);
      refreshSubmitState();
      form.querySelector('input, select, textarea')?.focus();
    });

    document.getElementById('copy').addEventListener('click', async () => {
      const txt = outputEl.textContent; if (!txt.trim()) return;
      await navigator.clipboard.writeText(txt);
      setStatus('Copied to clipboard.');
    });

    document.getElementById('download').addEventListener('click', () => {
      const txt = outputEl.textContent; if (!txt.trim()) return;
      const blob = new Blob([txt], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `first-call-script_${new Date().toISOString().replace(/[:.]/g,'-')}.txt`;
      document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
      setStatus('Download started.');
    });

    /* =========================================================================
       Render helper (library payload → text + buyer needs)
       ========================================================================= */
    function renderFromLibraryPayload(lib) {
      const s = lib.stages;
      const section = (title, body, extras=[]) => {
        let out = `\n${title}\n${'-'.repeat(title.length)}\n${body}\n`;
        extras.forEach(x => { if (Array.isArray(x) && x.length) out += `• ${x.join('\n• ')}\n`; });
        return out;
      };

      const text =
        section('Opening', s.opening.script) +
        section('Buyer pain', s.buyer_pain.script) +
        section('Buyer desire', s.buyer_desire.script) +
        section('Example', s.example.script, [s.example.proof_points_text||[]]) +
        section('Objections', s.objections.script, [s.objections.anticipated||[]]) +
        section('Call to action', s.call_to_action.script, [s.call_to_action.ctas_text||[]]);

      outputEl.textContent = text.trim();
      outputMeta.textContent = `Source: Larato Call Library · ${lib.meta.product_id} · ${lib.buyerType} · ${lib.meta.sales_mode} · Updated ${lib.meta.updated_at}`;
      copyBtn.disabled = false; downloadBtn.disabled = false;

      setSlot('intel-priorities', s.opening.buyer_needs_summary || []);
      setSlot('intel-pains', s.buyer_pain.buyer_needs_summary || []);
      setSlot('intel-triggers', s.buyer_desire.buyer_needs_summary || []);
      setSlot('intel-proof', s.example.proof_points_text?.length ? s.example.proof_points_text : (s.example.buyer_needs_summary||[]));
      setSlot('intel-objections', s.objections.anticipated?.length ? s.objections.anticipated : (s.objections.buyer_needs_summary||[]));
      setSlot('intel-ctas', s.call_to_action.ctas_text?.length ? s.call_to_action.ctas_text : (s.call_to_action.buyer_needs_summary||[]));
    }

    /* =========================================================================
       Submit: use Call Library first; fallback to generator
       ========================================================================= */
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      if (!allRequiredFilled(form)){
        const firstMissing = REQUIRED.find(n => {
          const el = form.elements[n] || document.getElementById(n);
          return !el || !String(el.value||'').trim();
        });
        const el = form.elements[firstMissing] || document.getElementById(firstMissing);
        if (el) el.focus();
        return;
      }

      const fd = Object.fromEntries(new FormData(form).entries());
      const variables = {
        seller_name: fd.seller_name || '',
        seller_company: fd.seller_company || '',
        prospect_name: fd.prospect_name || '',
        prospect_role: fd.prospect_role || '',
        prospect_company: fd.prospect_company || '',
        call_type: fd.call_type || callTypeSel.value || '',
        buyer_type: fd.buyer_behaviour || '',
        product: fd.product || '', // canonical id from index
        tone: fd.tone || '',
        length: fd.length || '',
        call_to_action: fd.call_to_action || '',
        context: fd.context || '',
        value_proposition: fd.value_proposition || ''
      };

      setBusy(true); setStatus('Loading from Larato Call Library…'); diag.open = false; diagJson.textContent = '';

      const lookup = {
        product: variables.product,
        buyerType: canonical.buyer(variables.buyer_type),
        mode: canonical.mode(variables.call_type)
      };

      try {
        const lib = await getCallScript(lookup);
        renderFromLibraryPayload(lib);

        const delta = computeDelta(lastOutput, outputEl.textContent);
        renderDelta(delta);
        lastOutput = outputEl.textContent; localStorage.setItem(OUTPUT_KEY, lastOutput);

        addActivity({ time: nowTime(), product: variables.product || '—', buyer_behaviour: variables.buyer_type || '—', length: variables.length || '—' });

        setStatus('Done. (Using Larato Call Library)');
        setBusy(false);
        document.getElementById('output-title').focus();
        return; // success — skip generator
      } catch (libraryErr) {
        setStatus('Call Library not available for this selection — using generator…');
      }

      // ---- Generator fallback (unchanged path) ----
      const payload = { pack: 'uk_b2b_sales_core', template: 'first_call_script_v2', variables };
      try {
        const res = await fetch('/api/generate', {
          method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(payload), credentials: 'include'
        });
        const text = await res.text();
        let data = {}; try { data = JSON.parse(text); } catch {}

        if (!res.ok) {
          if (res.status === 401) setStatus('Unauthorised. Please sign in again.', 'error');
          else if (res.status === 400) setStatus('Request was rejected. See diagnostics below.', 'error');
          else setStatus(`Error ${res.status}. See diagnostics below.`, 'error');
          diag.open = true; diagJson.textContent = JSON.stringify({ status: res.status, body: data || text }, null, 2);
          diag.scrollIntoView({behavior: prefersReducedMotion() ? 'auto':'smooth'}); diag.focus();
          return;
        }

        const out = (data.output || data.preview || '').trim();
        outputEl.textContent = out || '(No output returned.)';
        outputMeta.textContent = `Generated ${nowTime()}`;

        copyBtn.disabled = !out; downloadBtn.disabled = !out;

        const delta = computeDelta(lastOutput, out);
        renderDelta(delta);
        lastOutput = out; localStorage.setItem(OUTPUT_KEY, out);

        addActivity({ time: nowTime(), product: variables.product || '—', buyer_behaviour: variables.buyer_type || '—', length: variables.length || '—' });

        // intel uses labels, not ids
        renderIntel(getSelectedProductLabel(), buyerBehSel.value);
        if (out) injectRemindersFromScript(out);

        setStatus('Done. Script ready. (Generator fallback)');
        document.getElementById('output-title').focus();
      } catch (err) {
        setStatus('Network error. Please try again.', 'error');
        diag.open = true; diagJson.textContent = String(err);
      } finally {
        setBusy(false);
      }
    });

    /* =========================================================================
       Remembered call type chip
       ========================================================================= */
    function loadCallPref() {
      try {
        const pref = JSON.parse(localStorage.getItem(CALL_PREF_KEY) || 'null');
        if (pref?.call_type && !callTypeSel.value) callTypeSel.value = pref.call_type;
        if (pref?.remember === true) rememberCallType.checked = true;
      } catch {}
      updateMapIndicator();
    }
    function saveCallPrefIfRequested() {
      if (rememberCallType.checked && callTypeSel.value) {
        localStorage.setItem(CALL_PREF_KEY, JSON.stringify({ remember: true, call_type: callTypeSel.value }));
      } else if (!rememberCallType.checked) {
        localStorage.removeItem(CALL_PREF_KEY);
      }
      updateMapIndicator();
    }
    function updateMapIndicator() {
      const pref = JSON.parse(localStorage.getItem(CALL_PREF_KEY) || 'null');
      mapLabel.textContent = pref?.call_type || (callTypeSel.value || 'Not set');
    }

    /* =========================================================================
       Init
       ========================================================================= */
    (async function init(){
      hydrateUserBadge();

      // Load intel.json (for Buyer needs pane)
      try {
        const res = await fetch(INTEL_URL, { cache: 'no-store' });
        const raw = await res.json();
        intel = normaliseIntel(raw);
      } catch { intel = { products:{} }; }

      // Populate Product select from call-library index; fallback to intel.json
      try {
        const idx = await getIndex(); // from /src/lib/callLibrary.js
        const items = Array.isArray(idx?.products) ? idx.products : [];
        productSel.innerHTML = '<option value="">Select…</option>';
        for (const { id, label } of items) {
          const opt = document.createElement('option');
          opt.value = id;             // canonical id
          opt.textContent = label || id;
          productSel.appendChild(opt);
        }
      } catch {
        // Fallback: legacy intel.json products (keys)
        productSel.innerHTML = '<option value="">Select…</option>';
        Object.keys(intel.products || {}).forEach(p => {
          const opt = document.createElement('option');
          opt.value = p; opt.textContent = p;
          productSel.appendChild(opt);
        });
      }

      // Restore saved form state and remembered call type
      loadForm();
      loadCallPref();

      // Initial Buyer needs (use label for intel)
      if (productSel.value && buyerBehSel.value) {
        renderIntel(getSelectedProductLabel(), buyerBehSel.value);
      }

      // Ensure button state is correct on first paint
      refreshSubmitState();

      // Restore last output if present
      const last = localStorage.getItem(OUTPUT_KEY);
      if (last) { outputEl.textContent = last; copyBtn.disabled = false; downloadBtn.disabled = false; }
    })();
  })();
</script>
